<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Generator zdjęć z ramką — Konferencja</title>
  <meta name="description" content="Wgraj swoje zdjęcie, dopasuj je do ramki i pobierz gotową grafikę do mediów społecznościowych." />
  <style>
    :root{--bg:#0b0d12;--panel:#141824;--muted:#9aa0aa;--accent:#4f8cff;--text:#e6e9ef}
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(70% 60% at 50% 0%,#192038 0%,#0b0d12 60%);color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;letter-spacing:.2px}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    header{display:flex;gap:16px;align-items:center;justify-content:space-between;margin-bottom:14px}
    .title{font-weight:700;font-size:22px;line-height:1.2}
    .panel{background:var(--panel);border:1px solid #23283a;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);padding:16px}
    .grid{display:grid;grid-template-columns:1fr 360px;gap:16px}
    @media (max-width: 980px){.grid{grid-template-columns:1fr}}
    .stage{position:relative;display:flex;align-items:center;justify-content:center;min-height:360px;border-radius:14px;border:1px dashed #2b3150;background:linear-gradient(180deg,#0f1320,#0b0f1b)}
    canvas{max-width:100%;height:auto;border-radius:12px;display:block}
    .controls{display:grid;gap:10px}
    .group{background:#0f1320;border:1px solid #23283a;border-radius:12px;padding:12px}
    .group h3{margin:0 0 10px 0;font-size:14px;font-weight:700;color:#cdd3dd}
    .row{display:flex;align-items:center;gap:10px}
    label{font-size:13px;color:var(--muted)}
    input[type="file"]{display:none}
    .btn, .filelabel{display:inline-flex;align-items:center;justify-content:center;gap:8px;border-radius:10px;border:1px solid #33406b;background:#141b30;color:var(--text);padding:10px 12px;font-weight:600;cursor:pointer}
    .btn:hover,.filelabel:hover{background:#16203a}
    .btn[disabled]{opacity:.5;cursor:not-allowed}
    .primary{background:linear-gradient(180deg,#5c95ff,#4f8cff);border-color:#4f8cff;color:white}
    .primary:hover{filter:brightness(1.05)}
    .muted{color:var(--muted)}
    .slider{width:100%}
    .note{font-size:12px;color:#97a0ad}
    .drop{border:1px dashed #33406b;border-radius:10px;padding:10px;font-size:13px;color:#cbd3e0;background:#101526}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas; font-size:12px;background:#0b0f1c;border:1px solid #26304e;padding:2px 6px;border-radius:6px;color:#e8ecf8}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title">Generator zdjęć z ramką — Konferencja</div>
      <div class="muted">całkowicie w przeglądarce · brak wysyłania plików</div>
    </header>

    <div class="grid">
      <div class="panel stage" id="dropzone">
        <canvas id="canvas" aria-label="Podgląd grafiki"></canvas>
      </div>

      <div class="controls">
        <div class="panel group">
          <h3>1) Wgraj swoje zdjęcie</h3>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <label class="filelabel" for="file">Wybierz zdjęcie</label>
            <input id="file" type="file" accept="image/*" />
            <button class="btn" id="rotate">Obróć 90°</button>
            <button class="btn" id="reset">Wycentruj</button>
          </div>
          <p class="note" style="margin-top:8px">Możesz też przeciągnąć i upuścić plik na podgląd (lub wkleić z <span class="kbd">Ctrl/Cmd+V</span>).</p>
        </div>

        <div class="panel group">
          <h3>2) Dostosuj</h3>
          <label for="zoom">Powiększenie</label>
          <input id="zoom" class="slider" type="range" min="1" max="4" value="1" step="0.001" />
          <div class="note">Przeciągaj myszą/palcem, a kółkiem myszy powiększaj/pomniejszaj. Użyj <span class="kbd">Shift</span> by wolniej przesuwać.</div>
        </div>

        <div class="panel group">
          <h3>3) Pobierz</h3>
          <div class="row" style="gap:8px;flex-wrap:wrap">
            <button class="btn primary" id="downloadPng">Pobierz PNG</button>
            <button class="btn" id="downloadJpg">Pobierz JPG</button>
          </div>
          <p class="note" style="margin-top:8px">Plik wynikowy ma dokładnie rozmiar ramki. Dane nie opuszczają Twojego urządzenia.</p>
        </div>

        <div class="panel group">
          <h3>Informacje</h3>
          <div class="note">Ta strona działa w 100% lokalnie. Jeśli chcesz użyć wielu ramek, dodaj je do katalogu i rozwiń listę wyboru w kodzie (patrz komentarze w pliku).</div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // === KONFIGURACJA ===
  // Ustaw ścieżkę do swojej ramki PNG (z przezroczystym środkiem).
  const FRAME_SRC = 'Ramka nakładka.png';

  // Wymuś docelowe proporcje podglądu/eksportu (np. 4:5 dla Instagram post Portrait)
  const FORCE_OUTPUT_RATIO = 4/5; // szerokosc/wysokosc
  const FORCE_OUTPUT = true;      // gdy true, przytniemy ramkę centralnie do powyższych proporcji

  // === ELEMENTY ===
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');
  const fileInput = document.getElementById('file');
  const rotateBtn = document.getElementById('rotate');
  const resetBtn = document.getElementById('reset');
  const zoomSlider = document.getElementById('zoom');
  const downloadPngBtn = document.getElementById('downloadPng');
  const downloadJpgBtn = document.getElementById('downloadJpg');
  const dropzone = document.getElementById('dropzone');

  // === STAN ===
  const state = {
    frame: new Image(),
    frameLoaded: false,
    img: new Image(),
    imgLoaded: false,
    angle: 0, // 0, 90, 180, 270 (w stopniach)
    scale: 1,
    minScale: 1,
    x: 0, // przesunięcie zdjęcia względem środka
    y: 0,
    isPanning: false,
    lastX: 0,
    lastY: 0,
    devicePixelRatio: Math.max(1, window.devicePixelRatio || 1),
    // Obszar widoku (przycięty z ramki) w pikselach ramki
    view: { x: 0, y: 0, w: 0, h: 0 }
  };

  state.frame.crossOrigin = 'anonymous';
  state.img.crossOrigin = 'anonymous';

  // Ustal obszar widoku (przycięcie do FORCE_OUTPUT_RATIO w razie potrzeby)
  function computeViewRect(){
    const fw = state.frame.width;
    const fh = state.frame.height;
    if(!FORCE_OUTPUT || fw === 0 || fh === 0){
      return {x:0, y:0, w:fw, h:fh};
    }
    const target = FORCE_OUTPUT_RATIO; // w/h
    const ar = fw / fh;
    if (Math.abs(ar - target) < 1e-3) {
      return {x:0, y:0, w:fw, h:fh};
    }
    // Jeśli ramka jest "wyższa" (węższa) niż 4:5, przytnij GÓRĘ i DÓŁ.
    if (ar < target) {
      const newH = Math.round(fw / target);
      const y = Math.round((fh - newH) / 2);
      return {x:0, y, w:fw, h:newH};
    } else { // ramka jest szersza niż 4:5 -> przytnij BOKI
      const newW = Math.round(fh * target);
      const x = Math.round((fw - newW) / 2);
      return {x, y:0, w:newW, h:fh};
    }
  }

  function fitCanvasToView(){
    const dpr = state.devicePixelRatio;
    const {w, h} = state.view;
    canvas.width = Math.floor(w * dpr);
    canvas.height = Math.floor(h * dpr);
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    ctx.setTransform(dpr,0,0,dpr,0,0);
    centerImage();
  }

  function rotatedDims(){
    const a = (state.angle % 180 === 0);
    const iw = state.img.width;
    const ih = state.img.height;
    return a ? {w: iw, h: ih} : {w: ih, h: iw};
  }

  function computeMinScale(){
    if(!state.imgLoaded || !state.frameLoaded) return 1;
    const {w: iw, h: ih} = rotatedDims();
    const cw = state.view.w;
    const ch = state.view.h;
    return Math.max(cw / iw, ch / ih);
  }

  function centerImage(){
    if(!state.imgLoaded) return;
    state.minScale = computeMinScale();
    state.scale = Math.max(state.scale, state.minScale);
    zoomSlider.min = state.minScale.toFixed(3);
    zoomSlider.value = state.scale.toFixed(3);
    state.x = 0; state.y = 0;
  }

  function clampPan(){
    if(!state.imgLoaded) return;
    const {w: iw, h: ih} = rotatedDims();
    const cw = state.view.w;
    const ch = state.view.h;
    const dw = iw * state.scale;
    const dh = ih * state.scale;
    const minX = Math.min(0, (cw - dw)/2);
    const maxX = Math.max(0, (dw - cw)/2);
    const minY = Math.min(0, (ch - dh)/2);
    const maxY = Math.max(0, (dh - ch)/2);
    state.x = Math.max(minX, Math.min(maxX, state.x));
    state.y = Math.max(minY, Math.min(maxY, state.y));
  }

  function draw(){
    if(!state.frameLoaded){ return; }
    const cw = state.view.w;
    const ch = state.view.h;
    ctx.clearRect(0,0,cw,ch);

    // Zdjęcie
    if(state.imgLoaded){
      ctx.save();
      ctx.translate(cw/2 + state.x, ch/2 + state.y);
      ctx.rotate(state.angle * Math.PI/180);
      const iw = state.img.width;
      const ih = state.img.height;
      const dw = iw * state.scale;
      const dh = ih * state.scale;
      ctx.drawImage(state.img, -dw/2, -dh/2, dw, dh);
      ctx.restore();
    }

    // Ramka (fragment przycięty do 4:5)
    ctx.drawImage(state.frame, state.view.x, state.view.y, state.view.w, state.view.h, 0, 0, cw, ch);
  }

  function loadImageFromFile(file){
    if(!file) return;
    const url = URL.createObjectURL(file);
    const tmp = new Image();
    tmp.onload = () => {
      state.img = tmp;
      state.imgLoaded = true;
      state.angle = 0;
      state.scale = 1;
      centerImage();
      draw();
      URL.revokeObjectURL(url);
    };
    tmp.onerror = () => alert('Nie udało się wczytać pliku ze zdjęciem.');
    tmp.src = url;
  }

  // === Wczytanie ramki ===
  state.frame.onload = () => {
    state.frameLoaded = true;
    state.view = computeViewRect();
    fitCanvasToView();
    draw();
  };
  state.frame.onerror = () => alert('Nie udało się wczytać ramki: ' + FRAME_SRC);
  state.frame.src = FRAME_SRC;

  // === ZDARZENIA ===
  fileInput.addEventListener('change', (e) => {
    const f = e.target.files && e.target.files[0];
    loadImageFromFile(f);
  });
  ;['dragenter','dragover','dragleave','drop'].forEach(ev => {
    dropzone.addEventListener(ev, (e)=>{e.preventDefault(); e.stopPropagation();});
  });
  dropzone.addEventListener('drop', (e)=>{
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    loadImageFromFile(f);
  });
  window.addEventListener('paste', (e)=>{
    const items = e.clipboardData && e.clipboardData.items;
    if(!items) return;
    for(const it of items){
      if(it.type && it.type.startsWith('image/')){
        loadImageFromFile(it.getAsFile());
        break;
      }
    }
  });

  let pointerId = null;
  canvas.addEventListener('pointerdown', (e)=>{
    if(!state.imgLoaded) return;
    pointerId = e.pointerId; canvas.setPointerCapture(pointerId);
    state.isPanning = true;
    state.lastX = e.clientX; state.lastY = e.clientY;
  });
  canvas.addEventListener('pointermove', (e)=>{
    if(!state.isPanning || e.pointerId !== pointerId) return;
    const speed = e.shiftKey ? 0.5 : 1;
    state.x += (e.clientX - state.lastX) * speed;
    state.y += (e.clientY - state.lastY) * speed;
    state.lastX = e.clientX; state.lastY = e.clientY;
    clampPan();
    draw();
  });
  const endPan = (e)=>{
    if(e.pointerId !== pointerId) return;
    state.isPanning = false; canvas.releasePointerCapture(pointerId); pointerId=null;
  };
  canvas.addEventListener('pointerup', endPan);
  canvas.addEventListener('pointercancel', endPan);

  canvas.addEventListener('wheel', (e)=>{
    if(!state.imgLoaded) return;
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const cx = e.clientX - rect.left - rect.width/2;
    const cy = e.clientY - rect.top - rect.height/2;

    const zoomFactor = Math.exp(-e.deltaY * 0.0015);
    const prevScale = state.scale;
    const nextScale = Math.max(state.minScale, Math.min(4, prevScale * zoomFactor));
    const scaleDelta = nextScale / prevScale;

    state.x = (state.x + cx) * scaleDelta - cx;
    state.y = (state.y + cy) * scaleDelta - cy;
    state.scale = nextScale;
    zoomSlider.value = state.scale.toFixed(3);
    clampPan();
    draw();
  }, {passive:false});

  zoomSlider.addEventListener('input', ()=>{
    if(!state.imgLoaded) return;
    const prev = state.scale;
    state.scale = Math.max(state.minScale, Math.min(4, parseFloat(zoomSlider.value)));
    const scaleDelta = state.scale / prev;
    state.x *= scaleDelta; state.y *= scaleDelta;
    clampPan();
    draw();
  });

  rotateBtn.addEventListener('click', ()=>{
    if(!state.imgLoaded) return;
    state.angle = (state.angle + 90) % 360;
    state.minScale = computeMinScale();
    if(state.scale < state.minScale) state.scale = state.minScale;
    zoomSlider.min = state.minScale.toFixed(3);
    zoomSlider.value = state.scale.toFixed(3);
    state.x = 0; state.y = 0;
    draw();
  });

  resetBtn.addEventListener('click', ()=>{
    if(!state.imgLoaded) return;
    centerImage();
    draw();
  });

  function download(mime='image/png', quality){
    if(!state.frameLoaded) return;
    const out = document.createElement('canvas');
    out.width = state.view.w; out.height = state.view.h;
    const octx = out.getContext('2d');

    if(state.imgLoaded){
      octx.save();
      octx.translate(out.width/2 + state.x, out.height/2 + state.y);
      octx.rotate(state.angle * Math.PI/180);
      const iw = state.img.width, ih = state.img.height;
      octx.drawImage(state.img, -iw*state.scale/2, -ih*state.scale/2, iw*state.scale, ih*state.scale);
      octx.restore();
    }

    // Ramka (przycięta do obszaru widoku)
    octx.drawImage(state.frame, state.view.x, state.view.y, state.view.w, state.view.h, 0, 0, state.view.w, state.view.h);

    const url = out.toDataURL(mime, quality);
    const a = document.createElement('a');
    a.href = url;
    a.download = mime === 'image/png' ? 'konferencja.png' : 'konferencja.jpg';
    document.body.appendChild(a); a.click(); a.remove();
  }

  downloadPngBtn.addEventListener('click', ()=> download('image/png'));
  downloadJpgBtn.addEventListener('click', ()=> download('image/jpeg', 0.92));
})();
</script>
</body>
</html>
